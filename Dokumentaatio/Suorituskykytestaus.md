*Suorituskykytestaus:* 

Suorityskykytestaus on työn kannalta ehdottoman tärkeää, koska loppujen lopuksi se on ainoa olennainen ero Astarissa ja Dijkstrassa ja siten loppujen lopuksi oikeastaan koko työn aihe. Itse ohjelma onkin rakennettu ennen kaikkea tätä vertailua ja sen helpottamista varten.

Ohjelma luo toteutusdokumentissa esitetyillä arvoilla 100 satunnaista sokkeloa, jotka ovat kooltaan ja muodoltaan käyttäjän syötteiden mukaisia. Kumpikin algoritmi etsii lyhimmän reitin kussakin sokkelosta annetusta lähtöpisteestä annettuun maalipisteeseen ja tulostaa keskimääräisen ajan, joka algoritmilla meni maalipisteen ja siten lyhimmän reitin löytämiseen. Hieman yksinkertaistaen voidaan sanoa, että erilaisia skenaarioita on neljä: Lähtöpiste on keskellä sokkeloa ja maalipiste nurkassa, lähtöpiste on nurkassa ja maalipiste on keskellä, lähtöpiste on nurkassa ja maalipiste suorassa kulmassa, sekä lähtöpiste nurkassa ja maalipiste ristikkäisessä nurkassa. Muut tapaukset voidaan katsoa jonkin näistä variaatioksi. Vertailuissa on käytetty neliön muotoisia sokkeloita. Neliöiden sivun pituudet ovat järjestään 10, 50, 100, 200, 500, 1000 ja 2000, mikäli testitietokone on saanut viimeisen suoritettua. Tulokset kustakin tapauksesta, niiden kuvaajat sekä kuvaajat kummankin algoritmin sisäiseen vertailuun eri tapauksesta löytyvät Dokumentaatio-kansion polkualgoritmit.ods-tiedostosta. Valitettavasti en saanut taulukkoa näkymään suoraan GitHubissa, vaan se on avattava omalla koneella. Tämä onneksi onnistuu helposti View Raw -painikkeesta.

Tulos on selkeä: Astar on nopeampi. Jokainen tapaus ja syötekoko huomioiden Dijkstra käytti sokkelon ratkaisemiseen pienimmilläänkin keskimäärin noin 1,2-kertaisen ajan. Isoimmillaan ero on peräti lähes 14-kertainen. Koska O-analyysin kannalta molemmat algoritmit ovat yhtä tehokkaita - kuten toteutusdokumentissa on esitelty -, on tärkeä ymmärtää, mistä tulos johtuu, jotta voi arvioida tulosten mielekkyyttä. Ero tulee yksinkertaisuudessaan siitä, että Dijkstra arvioi vain jo kuljettua matkaa, kun Astar arvioi myös jäljellä olevaa matkaa ja valitsee seuraavan solmunsa sen mukaan. Dokumentaatio-kansiosta löytyvässä havainnekuva-tiedostossa on algoritmien toimintaa eräässä 25*25-sokkelossa havainnollistavat kaaviot. '.' ja '/' ovat kuljettavaa maastoa, '#' on seinä ja muut merkit solmuja, jotka algoritmi käsitteli. Havainnekuvista näkee selvän eron: Siinä missä Dijkstra on täyttänyt käytännössä koko sokkelon, on Astar lähtenyt keskeltä - kirjaimesta 'a' - määrätietoisesti kohti vasemman yläkulman maalisolmua.

Havainnekuvan tilanne on itse asiassa paras kuvaamaan Dijkstran ja Astarin eroja. Kuten taulukon luvuista ja kuvaajista näkee, on Astar selkeästi nopeampi tämänkaltaisissa tilanteissa. Joka kerta, kun testattu syötekoko kasvaa, kasvaa myös Dijkstran suhteellisesti enemmän vaatima aika verrattuna Astariin. Mielenkiintoista on myös se, että kun vertaa kummankin algoritmin omaa sisäistä vertailua eri tilanteissa, on "keskeltä kulmaan" -tilanne Astarille jopa helpoin päinvastaisen asetelman rinnalla, kun taas Dijkstralle haastavin. Tämä tietysti johtuu siitä, että Dijkstralla on asetelmassa käytännössä rajaton määrä vääriä suuntia, joihin erehtyä, kun taas Astar äkkää nopeasti oikean kulman ja suuntaa sitä kohti.

Toinen mielenkiintoinen havainto on päinvastaisessa tilanteessa, eli tilanteessa, jossa lähdetään kulmasta ja päädytään keskelle. Astarille tämä oli käytännössä samanlainen tilanne kuin ensimmäinenkin, mutta sen sijaan Dijkstralle tämä oli selvästi suotuisin tapaus. Syy on siinä, että Dijkstran väärät suunnat ovat hyvin rajalliset ja jäljelle jää käytännössä vain oikea suunta. Toisaalta pitää myös huomioida, että kulmasta keskelle suunnatessa, on etäisyys maaliin pienempi kuin muissa kulmista lähtevissä tilanteissa. Kuitenkin myös kasvunopeus on pienempi kuin muissa tilanteissa.

Äskeisen tilanteen jatke - kulmasta ristikulmaan - on suhteellisen eron kannalta Dijkstralle suotuisin tilanne: Suhteellinen ero on tässä tilanteessa selvästi pienin. Kuitenkin tulemme mielenkiintoisen tilanteen äärelle, sillä kulmasta ristikulmaan on geometrisesti ajatellen pisin matka verkossa, eli tietoa joutuu joka tapauksessa käsittelemään suuret määrät. Vaikka siis suhteellinen ero on tässä tilanteessa pienimmillään, on käsiteltävän aineiston suuruuden kannalta ajateltuna fiksua valita Astar tähänkin, sillä absoluuttisena aikaerona Astar on tässä selvä voittaja. Itse asiassa absoluuttinen ero ajassa on toiseksi suurin sitten keskeltä nurkkaan -tapauksen.

Kerätyn aineiston valossa on selvää, että Astar on tehokkaampi näistä kahdesta algoritmista huolimatta niiden samasta aikavaativuusluokasta. Lisäksi ohjelmaa kehitellessäni totesin, ettei Astarin toteuttaminen ole juuri monimutkaisempaa kuin Dijkstran, joten omaksi näkemyksekseni muotoutui, että Astar kannattaa valita kaikissa tapauksissa, joissa jäljellä oleva etäisyys pystytään jollain tapaa arvioimaan.
